name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (tag name)'
        required: true
        type: string

permissions:
  contents: read
  deployments: write

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    env:
      HAS_PRODUCTION_CONFIG: ${{ secrets.PRODUCTION_SSH_KEY != '' && secrets.PRODUCTION_HOST != '' && secrets.PRODUCTION_USER != '' }}
      HAS_SLACK: ${{ secrets.SLACK_WEBHOOK != '' }}
      DEPLOY_VERSION: ${{ inputs.version || github.ref_name }}
      DEPLOY_REF: ${{ inputs.version || github.ref }}
      GIT_SHA: ${{ github.sha }}
      GIT_ACTOR: ${{ github.actor }}
    environment:
      name: production
      url: https://coffeestudio.example.com
    
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version || github.ref }}
      
      - name: Create Deployment
        id: deployment
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: production
          description: 'Deploying ${{ inputs.version || github.ref_name }} to production'
      
      - name: Configure SSH
        if: env.HAS_PRODUCTION_CONFIG == 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
      
      - name: Backup Database
        if: env.HAS_PRODUCTION_CONFIG == 'true'
        run: |
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            set -e
            mkdir -p /backups
            echo "Creating database backup..."
            docker compose exec -T postgres pg_dump -U coffeestudio coffeestudio > /backups/pre-deploy-$(date +%Y%m%d-%H%M%S).sql
            echo "Backup created successfully"
          EOF
        continue-on-error: true
      
      - name: Deploy to Production
        if: env.HAS_PRODUCTION_CONFIG == 'true'
        run: |
          VERSION="$DEPLOY_VERSION"
          ssh "${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}" \
            "set -e; \
             cd /opt/coffeestudio; \
             echo 'Fetching latest tags...'; \
             git fetch --tags; \
             echo \"Checking out version ${VERSION}...\"; \
             git checkout \"${VERSION}\"; \
             echo 'Pulling Docker images...'; \
             docker compose pull; \
             echo 'Starting services...'; \
             docker compose up -d; \
             echo 'Running database migrations...'; \
             docker compose exec -T backend alembic upgrade head; \
             echo 'Deployment complete!'"
      
      - name: Deploy (No SSH - Placeholder)
        if: env.HAS_PRODUCTION_CONFIG != 'true'
        run: |
          echo "‚ö†Ô∏è PRODUCTION_SSH_KEY not configured"
          echo "This is a placeholder deployment step"
          echo "To enable actual deployment, configure these secrets:"
          echo "  - PRODUCTION_SSH_KEY: SSH private key for production server"
          echo "  - PRODUCTION_HOST: Production server hostname"
          echo "  - PRODUCTION_USER: SSH user for production server"
          echo ""
          echo "Version: $DEPLOY_VERSION"
          echo "Commit: $GIT_SHA"
      
      - name: Wait for Deployment
        run: sleep 45
      
      - name: Health Check
        id: health
        run: |
          if [ -n "${{ secrets.PRODUCTION_HOST }}" ]; then
            echo "Running health checks on production..."
            for i in {1..10}; do
              if curl -f https://coffeestudio.example.com/health; then
                echo "Health check passed"
                exit 0
              fi
              echo "Attempt $i failed, retrying..."
              sleep 10
            done
            echo "Health check failed after 10 attempts"
            exit 1
          else
            echo "Skipping health check (no production server configured)"
          fi
        continue-on-error: false
      
      - name: Rollback on Failure
        if: failure() && steps.health.outcome == 'failure' && env.HAS_PRODUCTION_CONFIG == 'true'
        run: |
          echo "‚ö†Ô∏è Health check failed, initiating rollback..."
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            set -e
            cd /opt/coffeestudio
            echo "Getting previous tag..."
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^)
            echo "Rolling back to $PREVIOUS_TAG..."
            git checkout $PREVIOUS_TAG
            docker compose up -d
            echo "Rollback complete to $PREVIOUS_TAG"
          EOF
      
      - name: Verify Rollback
        if: failure() && steps.health.outcome == 'failure' && env.HAS_PRODUCTION_CONFIG == 'true'
        run: |
          sleep 30
          echo "Verifying rollback..."
          for i in {1..5}; do
            if curl -f https://coffeestudio.example.com/health; then
              echo "Rollback successful, service is healthy"
              exit 0
            fi
            echo "Rollback verification attempt $i failed, retrying..."
            sleep 10
          done
          echo "‚ö†Ô∏è Rollback verification failed, manual intervention required!"
          exit 1
        continue-on-error: true
      
      - name: Update Deployment Status (Success)
        if: success()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ github.token }}
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}
          state: 'success'
          environment-url: https://coffeestudio.example.com
      
      - name: Update Deployment Status (Failure)
        if: failure()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ github.token }}
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}
          state: 'failure'
      
      - name: Notify Team
        if: always() && env.HAS_SLACK == 'true'
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": "üö® Production Deployment: ${{ job.status }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Production deployment *${{ job.status }}*\nVersion: `${{ inputs.version || github.ref_name }}`\nCommit: `${{ github.sha }}`\nActor: ${{ github.actor }}\nURL: https://coffeestudio.example.com"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ job.status == 'success' && '‚úÖ Deployment successful!' || '‚ùå Deployment failed! Check logs and consider rollback.' }}"
                  }
                }
              ]
            }
        continue-on-error: true
      
      - name: Create GitHub Release Notes
        if: success() && startsWith(github.ref, 'refs/tags/')
        uses: actions/github-script@v7
        with:
          script: |
            const tag = context.ref.replace('refs/tags/', '');
            try {
              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                name: `Release ${tag}`,
                body: `üöÄ Deployed to production\n\nCommit: ${context.sha}\nDeployed by: ${context.actor}`,
                draft: false,
                prerelease: false
              });
            } catch (error) {
              console.log('Release may already exist:', error.message);
            }
        continue-on-error: true
